#![deny(missing_docs)]

//! Set of definitions for backend-y stuff of the devotee project.
//!
//! General approach is following:
//! - Specific backend works with middleware and application instances;
//! - Middleware abstract backend specifics away;
//! - Application works with Middleware abstractions;

use std::time::Duration;

/// Middleware trait.
pub trait Middleware<'a, Control> {
    /// Event type to be handled;
    type Event;

    /// Specific context supporting the event handling.
    type EventContext;

    /// Surface to render to.
    type Surface;

    /// Context to be passed to the application.
    type Context;

    /// Render target to be passed to the application.
    type RenderTarget;

    /// Initialize during startup.
    fn init(&'a mut self, control: &'a mut Control);

    /// Provide context for the application update process.
    fn update(&'a mut self, control: &'a mut Control, delta: Duration) -> Self::Context;

    /// Handle event generated by the backend, return it if not consumed.
    fn handle_event(
        &mut self,
        event: Self::Event,
        event_context: Self::EventContext,
        control: &mut Control,
    ) -> Option<Self::Event>;

    /// Provide render context for the application to draw on.
    fn render(&'a mut self, surface: Self::Surface) -> Self::RenderTarget;
}

/// Application trait.
pub trait Application<'a, Context, RenderSurface, Converter> {
    /// Handle update logic.
    fn update(&mut self, context: Context);

    /// Render on the surface passed by the Middleware.
    fn render(&self, render_surface: &mut RenderSurface);

    /// Provide converter to convert data on the surface into `u32` values.
    fn converter(&self) -> Converter;

    /// Register the pause event.
    fn pause(&mut self) {}

    /// Register the resume event.
    fn resume(&mut self) {}
}

/// The surface for the Application to perform rendering on.
pub trait RenderSurface {
    /// Pixel data to be returned to the Middleware's render target.
    type Data;

    /// Get the width of the render surface in pixels.
    fn width(&self) -> usize;

    /// Get the height of the render surface in pixels.
    fn height(&self) -> usize;

    /// Get specific pixel data.
    ///
    /// # Panics
    /// For values outside of safe range may panic or may return garbage value.
    fn data(&self, x: usize, y: usize) -> Self::Data;
}

/// Converter from the Data value to `0xff_rr_gg_bb` format.
pub trait Converter {
    /// Data to be converted from.
    type Data;

    /// Convert passed data into `0xff_rr_gg_bb` value.
    /// `x` and `y` values represent pixel position in the surface, not in the target.
    fn convert(&self, x: usize, y: usize, data: Self::Data) -> u32;
}

/// Target to render to.
pub trait RenderTarget<Converter> {
    /// Stored `RenderSurface`.
    type RenderSurface;

    /// Error to be raised in case of a failure during presentation process.
    type PresentError;

    /// Get reference to the render surface.
    fn render_surface(&self) -> &Self::RenderSurface;

    /// Get mutable reference to the render surface.
    fn render_surface_mut(&mut self) -> &mut Self::RenderSurface;

    /// Present stored data.
    fn present(self, converter: Converter) -> Result<(), Self::PresentError>;
}

/// Context to be passed to the Application during the update routine.
pub trait Context<'a, Input> {
    /// Get stored input system.
    fn input(&self) -> &Input;

    /// Get simulated time passed since the previous update.
    fn delta(&self) -> Duration;

    /// Tell the backend to shutdown.
    fn shutdown(&mut self);
}

/// Input trait consumes external events.
pub trait Input<'a, EventContext> {
    /// Event to be handled.
    type Event;

    /// Handle event.
    /// Return the event if it is ignored.
    fn handle_event(
        &mut self,
        event: Self::Event,
        event_context: &EventContext,
    ) -> Option<Self::Event>;

    /// Handle the frame change.
    fn tick(&mut self);
}

/// Context for the event handling.
#[cfg(feature = "input-context")]
pub trait EventContext {
    /// Convert window position into render surface space.
    /// The `Ok` result means that the position is inside the surface, `Err` otherwise.
    fn position_into_render_surface_space(
        &self,
        position: (f32, f32),
    ) -> Result<(i32, i32), (i32, i32)>;
}
